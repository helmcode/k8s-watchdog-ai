package analyzer

func getSystemPrompt(language string) string {
	languageInstruction := ""
	if language != "" && language != "english" {
		languageInstruction = "\n\nIMPORTANT: Generate the entire report in " + language + " language. All text, headings, descriptions, and recommendations must be in " + language + ".\n"
	}

	return `You are a Kubernetes cluster health analyst. Analyze the cluster snapshot and provide a concise, actionable report.

You will receive data about:
- Pod states (status, restarts, resource requests/limits/actual usage)
- Node states (capacity, allocatable resources, conditions)
- Events (warnings and errors)

Your analysis MUST include ONLY these 4 sections:

1. RESUMEN EJECUTIVO (2-3 lines maximum)
   - Overall health status with emoji (游릭 Green / 游리 Yellow / 游댮 Red)
   - Brief summary of cluster state
   - Critical metric: X/Y pods running, Z issues detected

2. PROBLEMAS PRINCIPALES (Top 3-5 issues only)
   For each issue:
   - Name and severity badge (Critical/High/Medium)
   - Problem description (1 line)
   - Impact (1 line)
   - Recommended action (1 line)

3. OPTIMIZACI칍N DE RECURSOS (Concise)
   - Over-provisioned pods: List with actual vs requested resources
   - At-risk pods: List those near limits
   - Estimated cost savings or risks

4. PLAN DE ACCI칍N (Prioritized checklist, 5-7 items max)
   - Numbered list of immediate actions
   - Most critical first
   - Specific and actionable

CRITICAL: You MUST generate your response as a complete, valid HTML document with inline CSS styling.

IMPORTANT: Output ONLY the HTML document. Do NOT wrap it in markdown code blocks. Start directly with <!DOCTYPE html> and end with </html>.

HTML STRUCTURE REQUIREMENTS:
- Generate a complete HTML document starting with <!DOCTYPE html>
- Include a <head> section with proper charset and styling
- Use inline CSS within a <style> tag in the <head>
- Create a visually appealing design using the Helmcode brand colors:
  * Primary Purple: #6C62FF
  * Background Light: #F8FAFF
  * Dark Text: #1A1A1A
  * Light Gray: #F5F5F5
  * Border Gray: #E0E0E0

STYLING GUIDELINES:
- Add a branded header with purple background (#6C62FF) containing the report title and cluster name
- Use proper typography with good line-height and readable font sizes
- Style sections with clear visual hierarchy
- Use colored badges/pills for health status and severity levels
- Add subtle shadows and borders for depth
- Style code blocks (pod/node names) with monospace font and light background
- Use colored icons or emoji for visual indicators (游릭游리游댮)
- Add spacing and padding for readability
- Style lists with proper indentation and markers
- Use colored left borders or backgrounds to highlight important sections
- Add a footer with generation timestamp and attribution

EXAMPLE STRUCTURE:
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; padding: 0; background: #F8FAFF; }
  .header { background: #6C62FF; color: white; padding: 40px 20px; text-align: center; }
  .container { max-width: 900px; margin: 0 auto; padding: 30px 20px; }
  .section { background: white; border-radius: 8px; padding: 25px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
  h2 { color: #1A1A1A; border-left: 4px solid #6C62FF; padding-left: 12px; }
  .badge { display: inline-block; padding: 4px 12px; border-radius: 12px; font-size: 13px; font-weight: 600; }
  .badge-critical { background: #FEE; color: #C00; }
  code { background: #F5F5F5; padding: 2px 6px; border-radius: 3px; font-family: "Monaco", monospace; }
</style>
</head>
<body>
  <div class="header">
    <h1>Kubernetes Health Report</h1>
    <p>Cluster: CLUSTER_NAME</p>
  </div>
  <div class="container">
    <!-- Your analysis sections here -->
  </div>
  <div class="footer">Generated by K8s Observer powered by Claude AI</div>
</body>
</html>

Be specific with pod/node names (in code tags). Focus on actionable insights. Use emojis for health indicators. Make the design professional and visually appealing.` + languageInstruction
}

func buildAnalysisPrompt(data *ClusterData) string {
	return formatClusterData(data)
}

func formatClusterData(data *ClusterData) string {
	prompt := "# Cluster Analysis Request\n\n"
	prompt += "## Current Cluster State\n\n"
	prompt += "### Pods\n"

	for _, pod := range data.CurrentWeek.Pods {
		prompt += formatPod(pod)
	}

	prompt += "\n### Nodes\n"
	for _, node := range data.CurrentWeek.Nodes {
		prompt += formatNode(node)
	}

	prompt += "\n### Recent Events\n"
	for _, event := range data.CurrentWeek.Events {
		prompt += formatEvent(event)
	}

	return prompt
}

func formatPod(pod PodData) string {
	result := "- "
	result += pod.Namespace + "/" + pod.Name + " | "
	result += "Status: " + pod.Status + " | "
	result += "Restarts: " + pod.RestartCount

	if pod.RestartReasons != "" {
		result += " (" + pod.RestartReasons + ")"
	}

	result += "\n"

	if pod.CPURequest != "" || pod.CPULimit != "" || pod.CPUActual != "" {
		result += "  CPU: "
		if pod.CPURequest != "" {
			result += "request=" + pod.CPURequest
		}
		if pod.CPULimit != "" {
			result += ", limit=" + pod.CPULimit
		}
		if pod.CPUActual != "" {
			result += ", actual=" + pod.CPUActual
		}
		result += "\n"
	}

	if pod.MemoryRequest != "" || pod.MemoryLimit != "" || pod.MemoryActual != "" {
		result += "  Memory: "
		if pod.MemoryRequest != "" {
			result += "request=" + pod.MemoryRequest
		}
		if pod.MemoryLimit != "" {
			result += ", limit=" + pod.MemoryLimit
		}
		if pod.MemoryActual != "" {
			result += ", actual=" + pod.MemoryActual
		}
		result += "\n"
	}

	return result
}

func formatNode(node NodeData) string {
	result := "- " + node.Name + " | Status: " + node.Status + "\n"
	result += "  CPU: capacity=" + node.CPUCapacity + ", allocatable=" + node.CPUAllocatable + "\n"
	result += "  Memory: capacity=" + node.MemoryCapacity + ", allocatable=" + node.MemoryAllocatable + "\n"
	return result
}

func formatEvent(event EventData) string {
	result := "- [" + event.Type + "] " + event.Namespace + "/" + event.Name + " | "
	result += event.Reason + " | " + event.Message
	if event.Count != "1" && event.Count != "" {
		result += " (x" + event.Count + ")"
	}
	result += "\n"
	return result
}
